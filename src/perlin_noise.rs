use super::{algorithm::*, Float, Floor, Noise1D};

mod details {
    use super::Float;
    use rand::Rng;

    pub type NoisePermutions = [usize; 512];

    // fn perlin_permutations() -> [i32; 512] {
    //     const SIZE: usize = 256;
    // 	const OUT_SIZE: usize = 512;

    // 	const PERMUTATIONS: [i32; SIZE] = [
    // 		151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30,
    // 		69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94,
    // 		252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171,
    // 		168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60,
    // 		211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1,
    // 		216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86,
    // 		164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118,
    // 		126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170,
    // 		213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39,
    // 		253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34,
    // 		242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49,
    // 		192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254,
    // 		138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180,
    // 	];

    // 	let mut p = [0_i32; OUT_SIZE];
    // 	for i in 0..SIZE {
    // 		p[i] = PERMUTATIONS[i];
    // 		p[i + SIZE] = PERMUTATIONS[i];
    // 	}
    // 	p
    // }

    pub fn perlin_permutation_seeded(seed: u64) -> NoisePermutions {
        use rand::{distributions::Uniform, rngs::StdRng, SeedableRng};

        const SIZE: usize = 256;
        const OUT_SIZE: usize = 512;
        let mut rng: StdRng = SeedableRng::seed_from_u64(seed);
        let side = Uniform::new_inclusive(0, 255);

        let mut p: NoisePermutions = [0_usize; OUT_SIZE];
        for i in 0..SIZE {
            let v = rng.sample(side);
            p[i] = v;
            p[i + SIZE] = v;
        }
        p
    }

    pub const PERLIN_PERMUTATIONS: NoisePermutions = [
        151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30,
        69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94,
        252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171,
        168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60,
        211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1,
        216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86,
        164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118,
        126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170,
        213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39,
        253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34,
        242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49,
        192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254,
        138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180,
        151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30,
        69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94,
        252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171,
        168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60,
        211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1,
        216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86,
        164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118,
        126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170,
        213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39,
        253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34,
        242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49,
        192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254,
        138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180,
    ];

    pub const GRADIENT_1D: [f32; 16] = [
        -1.000, -0.875, -0.750, -0.625, -0.500, -0.375, -0.250, -0.125, 0.125, 0.250, 0.375, 0.500,
        0.625, 0.75, 0.875, 1.000,
    ];

    pub fn gradient_1d<T>(hash: usize, _x: T) -> T
    where
        T: Float,
    {
        let h: usize = hash & 15; // Convert lo 4 bits of hash code
        GRADIENT_1D[h].into() // * x;
    }
}

type Blender<T> = fn(T) -> T;

pub struct Perlin<T: Float> {
    perm: details::NoisePermutions,
    blender: Blender<T>,
}

impl<T: Float> Perlin<T> {
    pub fn new(blender: Blender<T>) -> Self {
        Perlin {
            perm: details::PERLIN_PERMUTATIONS,
            blender: blender,
        }
    }

    pub fn new_from_seed(blender: Blender<T>, seed: u64) -> Self {
        Perlin {
            perm: details::perlin_permutation_seeded(seed),
            blender: blender,
        }
    }
}

impl<T: Float> Noise1D<T> for Perlin<T> {
    fn eval(&self, x: T) -> T {
        const INDEX_MASK: usize = 255;
        let x0 = x.floor();
        let x1 = x0 + T::from(1.0);

        let dx = x - x0;
        let u = (self.blender)(dx);

        let a = self.perm[x0.as_index() & INDEX_MASK];
        let b = self.perm[x1.as_index() & INDEX_MASK];

        let gx0 = details::gradient_1d(a, x0);
        let gx1 = details::gradient_1d(b, x1);

        let p0 = gx0 * (x - x0);
        let p1 = gx1 * (x - x1);
        lerp(p0, p1, u)
    }
}

#[cfg(test)]
mod tests {
    use crate::algorithm;

    use super::*;

    #[test]
    fn perlin_tests() {
		let perlin = Perlin::<f32>::new(algorithm::quintic_curve);
		let result = perlin.eval(0.0);
		assert_eq!(result, 0.0);

		let result = perlin.eval(0.1);
		assert_eq!(result, -0.004689);
	}

	#[test]
	fn perlin_seeded_tests() {
		let perlin = Perlin::<f32>::new_from_seed(algorithm::quintic_curve, 12345);
		let result = perlin.eval(0.0);
		assert_eq!(result, 0.0);

		let result = perlin.eval(0.1);
		assert_eq!(result, 0.092529);
	}
}
